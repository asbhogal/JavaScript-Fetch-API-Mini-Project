    /*fetch('bison-plains.jpeg')                                                            // FETCH THE IMAGE FILE...
        .then(response => {                                                                 // ...THEN HANDLE THE PROMISE WITH A RESPONSE...
            console.log(response);                                                          // ...LOG THE DATA STREAM STORED IN THE RESPONSE IN THE CONSOLE
            return response.blob();                                                         // CONVERT THE RESPONSE INTO AN IMAGE BLOB. THIS TRIGGERS ANOTHER PROMISE.
        })
        .then(blob => {                                                                     // CHAIN THE RESPONSES USING then (AND CREATE A NEW VARIABLE CALLED blob)
            console.log(blob);                                                              // THE RESPONSE TO THE SECOND PROMISE
            document.getElementById('bison-plains').src = URL.createObjectURL(blob);        // TAKES THE DATA OF THE IMAGE (RETURNED AS A blob) AND PLACES IT INTO THE src ATTRIBUTE OF THE img DOM ELEMENT. THE . createObjectURL() FUNCTION IS REQUIRED TO TAKE THE blob OBJECT AND CONVERT IT INTO THE FORMAT AN img DOM ELEMENT WOULD EXPECT (AS THE DATA blob ISN'T IN THE FORMAT THE img DOM ELEMENT EXPECTS)
        });*/

        // SIMPLY PUT,:
            //  1. FETCH THE IMAGE
            //  2. LOOK AT THE RESOLVED PROMISE
            //  3. COMPLETE READING THE STREAM OF DATA INTO A blob
            //  4. OUTPUT THE img

// 1. CODE CALLS THE fetch FUNCTION WHICH WILL GIVE A SINGLE ARGUMENT - THE PATH TO THE RESOURCE (IN THIS CASE, AN IMAGE FILE PATH)
// 2. HANDLE THE SUBSEQUENT RESPONSE WITH THE DATA (ASSUMING SUCCESS) - INVOLVES A PROMISE RETURNED BY THE fetch. A PROMISE IS A WAY IN JS TO HANDLE AN ASYNCHRONOUS EVENT. THIS EVENT IS RESOLVED WHEN THE EVENT IS OVER AND THE DATA IS RETRIEVED. A 'FAIL-SAFE' IS ALSO CODED SHOULD AN ERROR BE RETURNED.
// 3. READ THE DATA RETURNED AND STORE IT IN A FORMAT THAT CAN BE WORKED WITH (e.g. TEXT, BLOB (IMAGE), ARRAY BUFFER, JSON etc.) FROM THE RESPONSE BODY. IN THIS CASE, IT INVOLVES CONVERTING THE DATA INTO A BLOB, WHICH TRIGGERS ANOTHER PROMISE. THIS CAN THEN BE CHAINED WITH ANOTHER .then
// 4. MAKE AN IMG HTML DOM ELEMENT WITH THE DATA RETURNED
// N.B. THE fetch OCCURS ASYNCHRONOUSLY, ie. TIME IS TAKEN TO RETRIEVE THE DATA FROM WHEN THE FUNCTION IS CALLED

// TWO NEW FEATURES SHOULD NOW BE USED HERE HOWEVER:
        // 1. ERROR HANDLING IF THE OBJECT CANNOT BE FETCHED
        // 2. ASYNC/AWAIT ENABLES HANDLING PROMISES IN A MORE READABLE AND INTUITIVE WAY
                // N.B. THE ABOVE WILL REPLACE .then

        catchImage()
            .catch(error => {
                console.log(error);
            });
        
        async function catchImage() {
            const response = await fetch('bison-plains.jpeg')
            const blob = await response.blob();
            document.getElementById('bison-plains').src = URL.createObjectURL(blob); 
        }

        /*  THIS ALTERNATIVE INVOLVES WRITING AN async FUNCTION THAT MAKES THE fetch REQUEST
            WHICH THEN TURNS THE BODY OF WHAT IS RETURNED IN THE HTTP RESPONSE TO A blob. THIS THEN
            CONVERTS THE blob INTO THE FORMAT THE DOM ELEMENT EXPECTS AND MONITORS FOR AN ERROR */

        /*  THE KEYWORD await CAN ONLY BE USED IN THE CONTEXT OF AN async FUNCTION. async IS A KEYWORD
            SPECIFYING THAT THIS FUNCTION IS GOING TO OCCUR ASYNCHRONOUSLY. IN THE ABOVE, A NEW FUNCTION 
            IS WRITTEN CALLED catchImage(). 

            THE fetch() FUNCTION IS STILL CALLED HERE IN LINE 34, HOWEVER THE RESULT IS THEN RETURNED TO A 
            NEW VARIABLE CALLED response ie. THE response EQUALS THE RESULT OF THE fetch FUNCTION. 

            HOWEVER, THIS IS WHERE THE await KEYWORD NOW COMES IN - SINCE fetch() IS AN ASYNCHRONOUS FUNCTION,
            THE await MUST BE ADDED. THIS LINE IS ESSENTIALLY THE SAME AS THE .then SEEN ABOVE. SINCE THIS IS 
            INSIDE AN async FUNCTION HOWEVER, THE CODE CAN BE WRITTEN IN A SINGLE LINE BY ESSENTIALLY STATING:
            "AWAIT THE RESULT OF fetch() AND STORE THE RESULT IN THE VARIABLE response". THIS IS THEN REPEATED
            WITH THE blob.

            WITH THE TWO LINES OF CODE (LINES 34 AND 35), A fetch() HAS BEEN CONDUCTED. A RESPONSE RECEIVED. blob
            IS THEN DECLARED AND THE blob RECEIVED. LINE 36 THEN PLACES THE blob (AS A URL) INTO THE DOM ELEMENT*/

        /* LINE 28 THEN CALLS THE async FUNCTION, WHICH HAS ALL THE async INSTRUCTIONS IN. THE catch() IS GOOD
            PRACTICE WHICH THEN HANDLES ERRORS AND ATTACHES IT TO THE async FUNCTION. AN async FUNCTION BY DEFINITION
            RETURNS A PROMISE.

        */
